/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

package com.facebook.react.uimanager;

import javax.annotation.Nullable;

import android.view.View;

import com.facebook.react.MeetyouReactBridge;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.Dynamic;

import java.util.HashMap;

/**
 * Wrapper for {@link ReadableMap} which should be used for styles property map. It extends
 * some of the accessor methods of {@link ReadableMap} by adding a default value property
 * such that caller is enforced to provide a default value for a style property.
 *
 * Instances of this class are used to update {@link View} or {@link CSSNode} style properties.
 * Since properties are generated by React framework based on what has been updated each value
 * in this map should either be interpreted as a new value set for a style property or as a "reset
 * this property to default" command in case when value is null (this is a way React communicates
 * change in which the style key that was previously present in a map has been removed).
 *
 * NOTE: Accessor method with default value will throw an exception when the key is not present in
 * the map. Style applicator logic should verify whether the key exists in the map using
 * {@link #hasKey} before fetching the value. The motivation behind this is that in case when the
 * updated style diff map doesn't contain a certain style key it means that the corresponding view
 * property shouldn't be updated (whereas in all other cases it should be updated to the new value
 * or the property should be reset).
 */
public class ReactStylesDiffMap {

  /* package */ final ReadableMap mBackingMap;

  final HashMap<String, Object> mHashMap;

  public ReactStylesDiffMap(HashMap<String, Object> map) {
    mBackingMap = null;
    mHashMap = map;
  }

  public ReactStylesDiffMap(ReadableMap props) {
    mBackingMap = props;
    mHashMap = null;
  }

  public boolean hasKey(String name) {
    if(mHashMap != null){
      return mHashMap.containsKey(name);
    }
    return mBackingMap.hasKey(name);
  }

  public boolean isNull(String name) {
    if(mHashMap != null){
      return !mHashMap.containsKey(name);
    }
    return mBackingMap.isNull(name);
  }

  public boolean getBoolean(String name, boolean restoreNullToDefaultValue) {
    boolean orgin = restoreNullToDefaultValue;
    if(mBackingMap != null){
      orgin = mBackingMap.isNull(name) ? restoreNullToDefaultValue : mBackingMap.getBoolean(name);
    }
    if (MeetyouReactBridge.getBridge().getListener() != null) {
      return MeetyouReactBridge.getBridge().getListener().getBoolean(name, orgin);
    }
    return orgin;
  }

  public double getDouble(String name, double restoreNullToDefaultValue) {
    double orgin = restoreNullToDefaultValue;
    if(mBackingMap != null){
      orgin = mBackingMap.isNull(name) ? restoreNullToDefaultValue : mBackingMap.getDouble(name);
    }
    if (MeetyouReactBridge.getBridge().getListener() != null) {
      return MeetyouReactBridge.getBridge().getListener().getDouble(name, orgin);
    }
    return orgin;
  }

  public float getFloat(String name, float restoreNullToDefaultValue) {
    float orgin = restoreNullToDefaultValue;
    if(mBackingMap != null){
      orgin = mBackingMap.isNull(name) ? restoreNullToDefaultValue : (float)mBackingMap.getDouble(name);
    }
    if (MeetyouReactBridge.getBridge().getListener() != null) {
      return MeetyouReactBridge.getBridge().getListener().getFloat(name, orgin);
    }
    return orgin;
  }

  public int getInt(String name, int restoreNullToDefaultValue) {

    int orgin = restoreNullToDefaultValue;
    if(mBackingMap != null){
      orgin = mBackingMap.isNull(name) ? restoreNullToDefaultValue : mBackingMap.getInt(name);
    }
    if(mHashMap != null){
      orgin = mHashMap.containsKey(name) ? (int)mHashMap.get(name) : restoreNullToDefaultValue;
    }
    if (MeetyouReactBridge.getBridge().getListener() != null) {
      return MeetyouReactBridge.getBridge().getListener().getInt(name, orgin);
    }
    return orgin;
  }

  @Nullable
  public String getString(String name) {
    String orgin = null;
    if(mBackingMap != null){
      orgin = mBackingMap.getString(name);
    }
    if (MeetyouReactBridge.getBridge().getListener() != null) {
      return MeetyouReactBridge.getBridge().getListener().getString(name, orgin);
    }
    return orgin;
  }

  @Nullable
  public ReadableArray getArray(String key) {
    if(mBackingMap == null){
      return null;
    }
    return mBackingMap.getArray(key);
  }

  @Nullable
  public ReadableMap getMap(String key) {
    if(mBackingMap == null){
      return null;
    }
    return mBackingMap.getMap(key);
  }

  @Nullable
  public Dynamic getDynamic(String key) {
    if(mBackingMap == null){
      return null;
    }
    return mBackingMap.getDynamic(key);
  }

  @Override
  public String toString() {
    if(mHashMap != null){
      return "{ " + getClass().getSimpleName() + ": " + mHashMap.toString() + " }";
    }
    return "{ " + getClass().getSimpleName() + ": " + mBackingMap.toString() + " }";
  }
}
